/**
 * Generated by orval v7.21.0 üç∫
 * Do not edit manually.
 * expense_tracker
 * A REST Api that offers various endpoints for handling shared expenses.
 * OpenAPI spec version: 0.3.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { useCallback } from 'react';

import type {
  AddUserToPotDTO,
  ExpenseDTO,
  NewExpenseDTO,
  NewPotDTO,
  PotDTO,
  RemoveUserFromPotDTO,
} from '../../model';

import { useCustomClient } from '../../custom-client';
import type { ErrorType, BodyType } from '../../custom-client';

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary Gets the list of all pots the bearer can view.
 */
export const useGetPotsHook = () => {
  const getPots = useCustomClient<PotDTO[]>();

  return useCallback(
    (signal?: AbortSignal) => {
      return getPots({ url: `/api/v1/pots`, method: 'GET', signal });
    },
    [getPots]
  );
};

export const getGetPotsQueryKey = () => {
  return [`/api/v1/pots`] as const;
};

export const useGetPotsQueryOptions = <
  TData = Awaited<ReturnType<ReturnType<typeof useGetPotsHook>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useGetPotsHook>>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPotsQueryKey();

  const getPots = useGetPotsHook();

  const queryFn: QueryFunction<
    Awaited<ReturnType<ReturnType<typeof useGetPotsHook>>>
  > = ({ signal }) => getPots(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useGetPotsHook>>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPotsQueryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useGetPotsHook>>>
>;
export type GetPotsQueryError = ErrorType<unknown>;

/**
 * @summary Gets the list of all pots the bearer can view.
 */

export function useGetPots<
  TData = Awaited<ReturnType<ReturnType<typeof useGetPotsHook>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useGetPotsHook>>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useGetPotsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates a pot from the given DTO for the bearer.
 */
export const useCreatePotHook = () => {
  const createPot = useCustomClient<PotDTO>();

  return useCallback(
    (newPotDTO: BodyType<NewPotDTO>, signal?: AbortSignal) => {
      return createPot({
        url: `/api/v1/pots`,
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        data: newPotDTO,
        signal,
      });
    },
    [createPot]
  );
};

export const useCreatePotMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useCreatePotHook>>>,
    TError,
    { data: BodyType<NewPotDTO> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<ReturnType<typeof useCreatePotHook>>>,
  TError,
  { data: BodyType<NewPotDTO> },
  TContext
> => {
  const mutationKey = ['createPot'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const createPot = useCreatePotHook();

  const mutationFn: MutationFunction<
    Awaited<ReturnType<ReturnType<typeof useCreatePotHook>>>,
    { data: BodyType<NewPotDTO> }
  > = (props) => {
    const { data } = props ?? {};

    return createPot(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePotMutationResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useCreatePotHook>>>
>;
export type CreatePotMutationBody = BodyType<NewPotDTO>;
export type CreatePotMutationError = ErrorType<unknown>;

/**
 * @summary Creates a pot from the given DTO for the bearer.
 */
export const useCreatePot = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useCreatePotHook>>>,
    TError,
    { data: BodyType<NewPotDTO> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<ReturnType<typeof useCreatePotHook>>>,
  TError,
  { data: BodyType<NewPotDTO> },
  TContext
> => {
  const mutationOptions = useCreatePotMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Gets the sum of all expenses for the given user of the given pot.
 */
export const useGetPotExpensesHook = () => {
  const getPotExpenses = useCustomClient<ExpenseDTO[]>();

  return useCallback(
    (potId: number, signal?: AbortSignal) => {
      return getPotExpenses({
        url: `/api/v1/pots/${potId}`,
        method: 'GET',
        signal,
      });
    },
    [getPotExpenses]
  );
};

export const getGetPotExpensesQueryKey = (potId?: number) => {
  return [`/api/v1/pots/${potId}`] as const;
};

export const useGetPotExpensesQueryOptions = <
  TData = Awaited<ReturnType<ReturnType<typeof useGetPotExpensesHook>>>,
  TError = ErrorType<void>
>(
  potId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<ReturnType<typeof useGetPotExpensesHook>>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPotExpensesQueryKey(potId);

  const getPotExpenses = useGetPotExpensesHook();

  const queryFn: QueryFunction<
    Awaited<ReturnType<ReturnType<typeof useGetPotExpensesHook>>>
  > = ({ signal }) => getPotExpenses(potId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!potId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useGetPotExpensesHook>>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPotExpensesQueryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useGetPotExpensesHook>>>
>;
export type GetPotExpensesQueryError = ErrorType<void>;

/**
 * @summary Gets the sum of all expenses for the given user of the given pot.
 */

export function useGetPotExpenses<
  TData = Awaited<ReturnType<ReturnType<typeof useGetPotExpensesHook>>>,
  TError = ErrorType<void>
>(
  potId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<ReturnType<typeof useGetPotExpensesHook>>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useGetPotExpensesQueryOptions(potId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Adds the given user to the pot, if Bearer is the owner of that pot.
 */
export const useAddUserToPotHook = () => {
  const addUserToPot = useCustomClient<void>();

  return useCallback(
    (potId: number, addUserToPotDTO: BodyType<AddUserToPotDTO>) => {
      return addUserToPot({
        url: `/api/v1/pots/${potId}`,
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        data: addUserToPotDTO,
      });
    },
    [addUserToPot]
  );
};

export const useAddUserToPotMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useAddUserToPotHook>>>,
    TError,
    { potId: number; data: BodyType<AddUserToPotDTO> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<ReturnType<typeof useAddUserToPotHook>>>,
  TError,
  { potId: number; data: BodyType<AddUserToPotDTO> },
  TContext
> => {
  const mutationKey = ['addUserToPot'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const addUserToPot = useAddUserToPotHook();

  const mutationFn: MutationFunction<
    Awaited<ReturnType<ReturnType<typeof useAddUserToPotHook>>>,
    { potId: number; data: BodyType<AddUserToPotDTO> }
  > = (props) => {
    const { potId, data } = props ?? {};

    return addUserToPot(potId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddUserToPotMutationResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useAddUserToPotHook>>>
>;
export type AddUserToPotMutationBody = BodyType<AddUserToPotDTO>;
export type AddUserToPotMutationError = ErrorType<void>;

/**
 * @summary Adds the given user to the pot, if Bearer is the owner of that pot.
 */
export const useAddUserToPot = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useAddUserToPotHook>>>,
    TError,
    { potId: number; data: BodyType<AddUserToPotDTO> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<ReturnType<typeof useAddUserToPotHook>>>,
  TError,
  { potId: number; data: BodyType<AddUserToPotDTO> },
  TContext
> => {
  const mutationOptions = useAddUserToPotMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Adds a new expense in the name of the user from the Bearer token to the pot with the given
pot_id if it exists.
 */
export const useAddExpenseHook = () => {
  const addExpense = useCustomClient<ExpenseDTO>();

  return useCallback(
    (
      potId: number,
      newExpenseDTO: BodyType<NewExpenseDTO>,
      signal?: AbortSignal
    ) => {
      return addExpense({
        url: `/api/v1/pots/${potId}`,
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        data: newExpenseDTO,
        signal,
      });
    },
    [addExpense]
  );
};

export const useAddExpenseMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useAddExpenseHook>>>,
    TError,
    { potId: number; data: BodyType<NewExpenseDTO> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<ReturnType<typeof useAddExpenseHook>>>,
  TError,
  { potId: number; data: BodyType<NewExpenseDTO> },
  TContext
> => {
  const mutationKey = ['addExpense'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const addExpense = useAddExpenseHook();

  const mutationFn: MutationFunction<
    Awaited<ReturnType<ReturnType<typeof useAddExpenseHook>>>,
    { potId: number; data: BodyType<NewExpenseDTO> }
  > = (props) => {
    const { potId, data } = props ?? {};

    return addExpense(potId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddExpenseMutationResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useAddExpenseHook>>>
>;
export type AddExpenseMutationBody = BodyType<NewExpenseDTO>;
export type AddExpenseMutationError = ErrorType<void>;

/**
 * @summary Adds a new expense in the name of the user from the Bearer token to the pot with the given
pot_id if it exists.
 */
export const useAddExpense = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useAddExpenseHook>>>,
    TError,
    { potId: number; data: BodyType<NewExpenseDTO> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<ReturnType<typeof useAddExpenseHook>>>,
  TError,
  { potId: number; data: BodyType<NewExpenseDTO> },
  TContext
> => {
  const mutationOptions = useAddExpenseMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Deletes the given pot if it does not contain any outstanding expenses and the caller
is the pot's owner.
 */
export const useDeletePotHook = () => {
  const deletePot = useCustomClient<void>();

  return useCallback(
    (potId: number) => {
      return deletePot({ url: `/api/v1/pots/${potId}`, method: 'DELETE' });
    },
    [deletePot]
  );
};

export const useDeletePotMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useDeletePotHook>>>,
    TError,
    { potId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<ReturnType<typeof useDeletePotHook>>>,
  TError,
  { potId: number },
  TContext
> => {
  const mutationKey = ['deletePot'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const deletePot = useDeletePotHook();

  const mutationFn: MutationFunction<
    Awaited<ReturnType<ReturnType<typeof useDeletePotHook>>>,
    { potId: number }
  > = (props) => {
    const { potId } = props ?? {};

    return deletePot(potId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePotMutationResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useDeletePotHook>>>
>;

export type DeletePotMutationError = ErrorType<void>;

/**
 * @summary Deletes the given pot if it does not contain any outstanding expenses and the caller
is the pot's owner.
 */
export const useDeletePot = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useDeletePotHook>>>,
    TError,
    { potId: number },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<ReturnType<typeof useDeletePotHook>>>,
  TError,
  { potId: number },
  TContext
> => {
  const mutationOptions = useDeletePotMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Removes the given user from the pot, if Bearer is the owner of that pot.
 */
export const useRemoveUserFromPotHook = () => {
  const removeUserFromPot = useCustomClient<void>();

  return useCallback(
    (potId: number, removeUserFromPotDTO: BodyType<RemoveUserFromPotDTO>) => {
      return removeUserFromPot({
        url: `/api/v1/pots/${potId}/remove_user`,
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        data: removeUserFromPotDTO,
      });
    },
    [removeUserFromPot]
  );
};

export const useRemoveUserFromPotMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useRemoveUserFromPotHook>>>,
    TError,
    { potId: number; data: BodyType<RemoveUserFromPotDTO> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<ReturnType<typeof useRemoveUserFromPotHook>>>,
  TError,
  { potId: number; data: BodyType<RemoveUserFromPotDTO> },
  TContext
> => {
  const mutationKey = ['removeUserFromPot'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const removeUserFromPot = useRemoveUserFromPotHook();

  const mutationFn: MutationFunction<
    Awaited<ReturnType<ReturnType<typeof useRemoveUserFromPotHook>>>,
    { potId: number; data: BodyType<RemoveUserFromPotDTO> }
  > = (props) => {
    const { potId, data } = props ?? {};

    return removeUserFromPot(potId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUserFromPotMutationResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useRemoveUserFromPotHook>>>
>;
export type RemoveUserFromPotMutationBody = BodyType<RemoveUserFromPotDTO>;
export type RemoveUserFromPotMutationError = ErrorType<void>;

/**
 * @summary Removes the given user from the pot, if Bearer is the owner of that pot.
 */
export const useRemoveUserFromPot = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useRemoveUserFromPotHook>>>,
    TError,
    { potId: number; data: BodyType<RemoveUserFromPotDTO> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<ReturnType<typeof useRemoveUserFromPotHook>>>,
  TError,
  { potId: number; data: BodyType<RemoveUserFromPotDTO> },
  TContext
> => {
  const mutationOptions = useRemoveUserFromPotMutationOptions(options);

  return useMutation(mutationOptions);
};
